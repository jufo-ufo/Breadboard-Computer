\documentclass{scrartcl}

\usepackage{graphicx}
\usepackage[siunitx, RPvoltages, european]{circuitikz}

\usepackage[ngerman]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[T1]{fontenc}
\usepackage{xcolor}
\usepackage{tikz}
\usepackage[breaklinks=true]{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[babel,german=quotes]{csquotes}
\usepackage[style=numeric, backend=biber]{biblatex}
\usepackage{listings}
\usepackage{bytefield}
\usepackage{longtable}

\lstdefinestyle{asm}{
}

\addbibresource{ref.bib}

\graphicspath{ {../images} }

\KOMAoptions{parskip=full}

\begin{document}

\title{Platinencomputer - Handbuch}
\author{Alexander Wersching und Simon Walter}
\date{2021}
\maketitle
\newpage


\tableofcontents
\newpage

\section{Einführung}
\subsection{Ziel diese Dokuments}
Dieses Dokument soll die Funktionsweise unseres Platinencomputers beschreiben. Dabei soll nicht auf die tatsächliche auf Implementation wertgelegt werden, aber viel mehr auf die einzelnen Features und Funktionen. Diese Spezifikation wurde vor dem Bau des Computers bzw. des Emulators geschrieben, um eine Grundlage für alle weiteren Konstruktionsschritte zu haben. 

\subsection{Geschichte}
Dieses Dokument hat sehr viel Änderung durchleben müssen, diese kann unter \url{https://github.com/jufo-ufo/Breadboard-Computer} eingesehen werden. Zudem hatte diese Spezifikation zwei, wenn auch nicht vollständige, Vorgänger: \url{https://github.com/jufo-ufo/Breadboard-Computer/blob/master/specification_v0.1.txt} und \url{https://github.com/jufo-ufo/Breadboard-Computer/blob/master/specification_v0.2.txt}. Wobei die zweite Fassung als Basis dieses Dokuments diente.




\section{Spezifikation des Computers}
Ein Computer hat eine Reihe verschiedener ``high-level`` Aufgaben und Features, die es ihm erlauben, seiner Tätigkeiten nach zu gehen! 
Diese Features können wie folgt auf gegliedert werden: Register, Memory, Input/Output, Interrupts, Supervisor-/Usermode und der Instruktionssatz.

Aber um zuerst ein paar Standards festzulegen: Der Computer hat eine Daten-/Adressenlänge von 16 Bit, d.h. er kann maximal 16 Bit auf einmal operieren bzw. können maximal 16 Bit an Daten/Adressen im Computer auf einmal bewegt werden. Mehr dazu in \autoref{section:comment:datalength}

Unsere Computer ist eine von Neuman-Maschine, d.h. sowol Daten als auch Programm während in einem Hauptspeicher (Memory) gespeichert


\subsection{Registers}
Register sind kleine, sehr schnelle Speichereinheiten, die genutzt werden können, um Zwischenergebnisse, lokal Variablen, Argumenten für Funktionen zu speichern oder um Daten im Computer zwischen den einzelnen Komponenten zu verschieben. Aus jedem Register kann \emph{gelesen} (\emph{Kopierten} des alten Wertes an einen anderen Ort) oder \emph{geschrieben} werden (den alten Wert mit einem neuen Wert \emph{überschreiben})

Der Computer besitzt $8$ verschiedene, jeweils $16$ Bit lange Register. Jedes Register hat dabei eine eigene Registernummer (RN). Machen Register erfüllen zudem noch spezielle Aufgaben und sollten auch nur so verwendet werden. Diese Funktionen sind in \autoref{table:register} zu sehen.

Mehr zur Registeranzahl in \autoref{section:comment:register_number}

\begin{center}
	\begin{table}[h]
		\caption{\label{table:register} Registeraufteilung}
		\begin{tabular}{l | l | l}
			RN & Name & Funktion\\
			\hline
			$0$ & ZERO & Konstante $0\text{x}0000$; Schreiben hat keinen Effekt\\
			$1$ & IP & Instruction Pointer, zeigt auf aktuell auszuführende Instruktion\\
			$2$ & SP & Stack Pointer, zeigt auf obersten Wert des Stacks, siehe \ref{section:stack} \\
			$3$ & A & Allzweck Register ohne besonderen Aufgaben \\
			$4$ & B & Allzweck " \\
			$5$ & C & Allzweck " \\
			$6$ & D & Allzweck " \\
			$7$ & FLAG & Enthält alle wichtigen Flaggen, siehe \autoref{section:flags} \\
		\end{tabular}
	\end{table}
\end{center}

Die Register A-D sind dabei Register, welche frei für jede Nutzung zur Verfügung stehen. Es ist \emph{stark zu empfehlen}, die Spezialregister (ZERO, IP, SP und FLAG) \emph{nicht} für die Speicherung von Daten zu verwenden, da dies evtl. Programmabläufe stark stören könnte oder im Falle von ZERO oder den letzten 8 bit des Flaggen Registers im Usermode nicht möglich ist. Sie sind ausdrücklich nur für ihre zugewiesenen Aufgaben da.

\subsubsection{\label{section:DataMov} Kopieren und Bewegen von Daten}

Das Kopierten eines Wertes in ein Register ist mit der MOV-Instruktion möglich. Die MOV-Instruktion nimmt dabei als ersten Operanden das Ziel Register und als zweiten Operanden das Quellenregister oder eine Konstante an. MOV kopiert nun den Wert des zweiten Operanden in den des Ersten. Die Notation ist dabei wie folgt: 

\text{MOV <Ziel-Register> <Qullen-Register/Konstante>}

Eine Übersicht über alle Instruktion ist in \autoref{section:insSet} vermerkt.

\subsubsection{\label{section:flags}Flaggen}

Das Register FLAG enthält alle Statusflaggen. Eine Flagge kann entweder gesetzt oder nicht gesetzt sein, daher kann jede Flagge als ein Bit repräsentiert werden. Jedes Bit in FLAG stellt daher eine Flagge da. Flaggen werden bei unterschiedlichen Ereignissen geschaltet. Dies und welche Flaggen es gibt, ist in \autoref{table:flag} zusehen.

\begin{center}
	\begin{table}[h]
		\caption{\label{table:flag}Flaggenaufteilung in FLAG}
		\begin{tabular}{l | l | l | l}
			Bit & Name & Funktion & Schaltung \\
			\hline
			 0 & OF  & Intager Overflow einer Rechenoperation & Bei jeder ALU Operation\\
			 1 & E   & Gleichheit zweier Werte & TEST arg[0] = arg[1]\\
			 2 & G   & Ungleicheit ($>$) zweier Werte & TEST arg[0] > arg[1]\\
			 3 & L   & Ungleicheit ($<$) zweier Werte & TEST arg[0] < arg[0]\\
			 4 &  &  &  \\
			 5 &  &  &  \\
			 6 &  &  &  \\
			 7 &  &  &  \\
			 8 &  &  &  \\
			 9 &  &  &  \\
			10 &  &  &  \\
			11 &  &  &  \\
			12 &  &  &  \\
			13 &  &  &  \\
			14 &  &  &  \\
			15 & OINT & Overwride Interruption, siehe \autoref{section:interrupts} &  \\
			15 & SUP & Supervisor-/Usermode, siehe \autoref{section:supervisor} & 
		\end{tabular}
	\end{table}
\end{center}


Alle Flaggen, die mit TEST als Schaltung gekennzeichnet sind, werden bei der Ausführung der TEST Operation geschaltet.

Das FLAG Register verhält sich ebenfalls wie ein Register, daher können Flagge auch per Hand gesetzt oder nicht gesetzt werden. Eine Ausnahme machen die letzten 8 Flaggen darunter SUP und OINT die nur geschaltet werden können, wenn der Computer sich im Supervisormode befindet, siehe \autoref{section:supervisor}. Ein Schalten im Usermode hat keinen Effekt.

Neben der MOV-Instruktion gibt es auch die sogentannten kondizionallen MOV-Instruktionen. Diese funktionieren genauso wie die MOV-Instruktion, indem sie das Quellen-Register/Konstante in das Ziel-Register kopiert, aber dies jedoch nur tun, wenn die entsprechende Flagge gesetzt ist. Die Notation dafür ist wie folgt:

\text{M<Flagge> <Ziel-Register> <Quellen-Register/Konstante>}

Daher ergeben sich folgende kondizionallen MOV-Instruktionen: ME (E Flagge), MOF (OF Flagge), MG (G Flagge), ML (L Flagge), MI (ONIT Flagge), MS (SUP Flagge).

Eine Übersicht über alle Instruktion ist in \autoref{section:insSet} vermerkt.

\subsubsection{\label{section:arthimatik}Arithmetische Operationen und Bitmanipulation}

Der Computer hat zudem die Fähigkeit, arithmetische Operation und Bit-Manipulation durchzuführen. Alle Operationen sind dabei binär daher Kombinieren zwei Eingangswerte oder Operanden zu einem Ausgangswert. Die Ausnahme macht dabei die NOT-Instruktion, die nur einen Eingangswert annimmt und auf diesen ein Bitweises Nicht durchführt. 

Alle arithmetischen Operationen und Bit-Manipulation funktionieren dabei immer gleich: Sie kombinieren das erste Quelle-Register mit dem zweiten Quellen-Register und schreiben das Ergebnis in das Ziel-Register. Dabei ist zu beachten, dass das zweite Quellen-Register durch einen konstanten Wert ersetzt werden kann. Die Notation dafür sie wie folgt aus:

\text{<Operation> <Ziel-Register> <Quellen-Register 1> <Quellen-Register 2/Konstante>}

Der Computer unterstützt dabei folgende Operationen: Addition (ADD), Subtraktion (SUB), Multiplikation (MUL), Division (DIV), Bitweises exklusives Oder (XOR), Bitweise Und (AND), Bitweises Oder (OR), Bitweises Nicht (NOT)

Eine Übersicht über alle Instruktion ist in \autoref{section:insSet} vermerkt.

Wichtig zusagen ist bei das alle Operationen ($f(x_1, x_2) = y \mod 65536$) gilt $65535 \ge y \ge 0$ ist wo bei gilt $y \in \mathbb{N}$. Der springende Punk ist bei, dass bei einer Rechnung wie $65535 + 1$ das Ergebnis nicht $65536$ ist, sondern $0$. Bei so einem “Overflow“ wird die OF-Flagge gesetzt. Dieses Problem tritt auf da wir nur $16$ Bit als Datenlänge zu Verfügung haben, mehr dazu in \autoref{section:comment:datalength}




\subsection{\label{section:memory}Memory}

Während die Register für lokale Variablen und Zwischenergebnisse gedacht sind, ist Memory (Arbeitsspeicher) für die Speicherung von größeren Datenmengen gedacht.

Es ist in 65536 einzelne und unabhängige Speicherzellen (Jede 16 Bit große) aufgeteilt. Jeder Zelle ist einer Adresse, welche von 0 bis 65535 reicht, zugeordnet. Der Computer kann damit auf $65536 \text{ words}$ oder $131072 \text{ bytes}$ ($\approx 131.0 \text{kb}$) zugreifen.
\footnote{Die Größe messen wir in words (w) oder in kilowords (kw), wobei $1 \text{ word} = 2 \text{ bytes} = 16 \text{ Bit}$.}. Wichtig ist das die Gesamt Größe theoretisch weitaus größer sein kann, dank Banking siehe \autoref{section:banking}.

Memory wird dabei über LD- und STR-Instruktionen gesteuert. Die LD-Instruktion kopiert einen Wert aus Memory und schreibt ihn in ein Ziel-Register, während STR an der angegebenen Adresse den Wert mit dem Wert des Quellen-Register überschreibt. Die Adresse wird zusammen gesetzt durch die Addition des Address-Register1 und entweder in dem Address-Register2 oder einer Konstante. Die Notation sieht dabei wie folgt aus:

\text{LD <Ziel-Register> <Address-Register1> <Address-Register2/Konstante>}


\text{STR <Quellen-Register> <Address-Register1> <Address-Register2/Konstante>}

Eine Übersicht über alle Instruktion ist in \autoref{section:insSet} vermerkt.

Zudem wurden bestimmte Bereichen bestimmte Aufgaben bzw. Funktionen zugewiesen, wie in \autoref{fig:memoryMap} zu stehen. Die zwei Hardware Stacks sind dort gekenzeichnet mit $\uparrow$, mehr dazu Stacks in \autoref{section:stack}

Die mit Supervisor gekennzeichneten Bereich können nur dann gelesen oder geschrieben werden, wenn sich der Computer im Supervisormode befindet. Mehr zu Supervisormode in \autoref{section:supervisor}. Der Bereich, der mit ROM versehen wurde, ist dabei nicht beschreibbar, sondern kann nur gelesen werden. Eine STR-Instruktion hat keine Wirkung. Eine Änderung des Inhalts der ROM Bereiche ist nur durch den Austausch des darunterliegen physikalischen ROM-Chips möglich.

\begin{figure}[h]
	\centering
	\caption{Memory Karte}
	\label{fig:memoryMap}
	\begin{bytefield}[leftcurly=., rightcurly=., leftcurlyspace=0pt, rightcurlyspace=0pt]{16}
		
		\begin{leftwordgroup}{\small \texttt{0x0000}}
			\bitbox[lrt]{16}{}
		\end{leftwordgroup}\\
		\wordbox[lr]{2}{ROM Supervisor\\$16384 \text{w} \approx 16.3 \text{kw}$} \\
		\begin{leftwordgroup}{\small \texttt{0x3fff}}
			\bitbox[lr]{16}{}
		\end{leftwordgroup}\\

		\begin{leftwordgroup}{\small \texttt{0x4000}}
			\bitbox[lrt]{16}{}
		\end{leftwordgroup}\\
		\begin{rightwordgroup}{\large $\uparrow$ User Stack}
			\wordbox[lr]{3}{RAM (Bank Slot 1)\\$18431 \text{w} \approx 18.4 \text{kw}$} \\
		\end{rightwordgroup}
		\begin{leftwordgroup}{\small \texttt{0x57ff}}
			\bitbox[lr]{16}{}
		\end{leftwordgroup}\\

		\begin{leftwordgroup}{\small \texttt{0x5800}}
			\bitbox[lrt]{16}{}
		\end{leftwordgroup}\\
		\wordbox[lr]{3}{RAM (Bank Slot 2)\\$18431 \text{w} \approx 18.4 \text{kw}$} \\
		\begin{leftwordgroup}{\small \texttt{0xcfff}}
			\bitbox[lr]{16}{}
		\end{leftwordgroup}\\

		\begin{leftwordgroup}{\small \texttt{0xd000}}
			\bitbox[lrt]{16}{}
		\end{leftwordgroup}\\
		\begin{rightwordgroup}{\large $\uparrow$ Supervisor Stack}
			\wordbox[lr]{2}{RAM Supervisor\\$12287 \text{w} \approx 12.3 \text{kw}$} \\
		\end{rightwordgroup}
		\begin{leftwordgroup}{\small \texttt{0xffff}}
			\bitbox[lrb]{16}{}
		\end{leftwordgroup}

	\end{bytefield}
	
\end{figure}

\subsubsection{\label{section:banking}Banking}


Banken sind externe Memory Module, die eingesteckt werden können. Alle Banken sind gleich groß ($~18.4\text{kw} = 36.8\text{kb}$) und der Computer unterstützt maximal $65536$ unterschiedliche Banken. Jede Bank hat dabei eine ID (BID), die von $0$ bis $65535$ reicht.

Der Computer hat zwei Bank-Slots (Slot 1 \texttt{0x4000 - 0x3fff} und Slot 2 \texttt{0x4000 - 0x57ff}). Er kann nun auf jede dieser Slots eine der theoretisch $65536$ Bank legen
\footnote{Es ist dabei möglich, die gleiche Bank auf beide Slots zu legen, auch wenn das nur bedingt nützlich ist.}. Das Banken legen lässt sich über die SBK1- (Select Bank 1) und SBK2- (Select Bank 2) Instruktion erreichen. Die BIN kann dabei als Konstante oder als Register vorliegen. Die Notation ist dabei wie folgt:

\text{SBK<1/2> <BIN-Register/Konstante>}

Eine Übersicht über alle Instruktion ist in \autoref{section:insSet} vermerkt.

Somit führt das Beschreiben/Lesen an einer Adresse welche einem Bank-Slot zugeordnet ist, zudem Beschreiben/Lesen der ausgewählte Bank.

Durch dieses System lassen sich $65536 * ~18.4\text{kw} = 1.2\text{Gw} = 2.4\text{GB}$ an Arbeitsspeicher ansprechen.

Das Bankensystem dient zudem dazu, Prozesse voneinander zu isolieren, da im Usermode der Computer die Bank nicht verändern kann, siehe \autoref{section:supervisor}.

\subsubsection{\label{section:stack}Hardware Stack}

Der Stack (oder, auch Stapelspeicher) ist eine LIFO (Last In First Out) Datenstruktur. Sie dient hauptsächlich dazu, Subroutinen zu verwalten. 

Er funktioniert dabei wie ein Papierstapel. Es kann ein Wert auf den Stack gelegt, werden (PUSH-Instruktion) oder ein Wert von oben abgehoben werden (POP-Instruktion). Wobei der Wert, der auf den Stack gelegt bzw. abgehoben werden soll, entweder im Quellen-Register bzw. Zeil-Register oder als Konstante vorliegt. Die Notation ist dabei wie folgt:

\text{PUSH <Quellen-Register/Konstante>}

\text{POP  <Ziel-Register>}

Der Stack liegt dabei physisch in Memory vor. Jedes Element des Stacks okkupiert dabei eine Memory-Zelle (16 Bit). Das Stack-Point Register-(SP) hält die Adresse, welche die nächste freie Memory-Zelle zeigt, die eins über dem obersten Wert des Stacks liegt. Der Stack wächst dabei von hohen Adressen zu niedrigen Adressen, wie in \autoref{fig:stack-dir} zusehen. 

Bei einer PUSH Instruktion wird zuerst an die Stelle auf die SP zeigt der Wert des Qullen-Register/Konstante geschrieben und darauf der SP um $1$ inkriminiert. POP dagegen dekrementiert zuerst den SP um $1$ und kopiert dann den Wert von der Stelle auf welche SP zeigt in das Ziel-Register.

Zudem gibt es noch die RET- und CALL-Instruktionen. \text{RET} ist äquivalent zu \text(POP IP) und CALL ist äquivalent zu \text{PUSH IP; MOV IP <Quellen-Register/Konstante>}. Die Notation ist dabei wie folgt:

\text{RET}

\text{CALL <Quellen-Register/Konstante>}

Fundamental hat der Computer zwei Stacks. Der Supervisor-Stack beginnt bei \texttt{0xffff} und wird genutzt, wenn die SUP Flagge gesetzt ist. Der User-Stack beginnt bei \texttt{0x57ff}, also am Ende des Bank-Slots 1 und wird genutzt, wenn die SUP Flagge nicht gesetzt ist.

POP, PUSH, CALL und RET schalten automatisch zwischen Supervisor-Stack und User-Stack bei Änderung der SUP-Flagge.

\begin{figure}[h]
	\centering
	\caption{Stack Aufbau}
	\label{fig:stack-dir}

	\begin{bytefield}[leftcurly=., rightcurly=.]{16}
		\begin{rightwordgroup}{\small niedrige Addressen}
			\wordbox[lrb]{1}{}
		\end{rightwordgroup} \\
		\begin{leftwordgroup}{\small SP $\rightarrow$}
			\wordbox[lrb]{1}{}
		\end{leftwordgroup} \\
		\wordbox[lrb]{1}{Wert n} \\
		\begin{rightwordgroup}{\small $\uparrow$ Stack-Richtung}
			\wordbox[lrb]{1}{...}
		\end{rightwordgroup} \\
		\wordbox[lrb]{1}{Wert 1} \\
		\wordbox[lrb]{1}{Wert 0} \\
		\begin{rightwordgroup}{\small hohe Adressen}
			\wordbox[lr]{1}{}
		\end{rightwordgroup}
	\end{bytefield}

\end{figure}




\subsection{\label{section:io}Input/Output}

Der Computer hat zudem die Möglichkeit mit verschieden IO-Geräte zu interagieren.
Die Komunikation läuft über die sogenannten IO-Ports.
Der Computer hat physische Anschlüsse an denen IO-Geräte angesteckt werden können.
Die Struktur dieser Anschlüsse sieht wir folgt aus:

\begin{center}
	\begin{table}[h]
		\caption{\label{table:IOPins}}
		\begin{tabular}{l | l}
			\# & Funktion \\
			\hline
			00 & GND \\
			01 & Vcc \\
			02-17 & 16Bit Daten \\
			18 & Iin-Enable \\
			19 & Din-Enable \\
			20 & Dout-Enable \\
			21 & Clock
 		\end{tabular}
	\end{table}
\end{center}

Dabei bekommt jedes IO-Gerät eine eigene ID (IO-ID), welche im Bereich von $0$ bis $65535$ liegen darf, wobei davon aufgrund von physikalischen beschränkungen vermutlich nur die ersten -zig verwendet werden.
Die Interaktion funktioniert dabei über drei Instruktionen:

\begin{center}
	\begin{table}[h]
		\caption{\label{table:IOInstructions}}
		\begin{tabular}{r | r | l}
			kurzform & Ausgeschrieben & funktion \\
			\hline
			Iin & Instruktion Eingang & Computer schreibt eine Instruktion ans I/O-Gerät \\
			Din & Daten Eingang & Computer schreibt 16-Bit Daten ans I/O-Gerät \\
			Dout &  Daten Output & Computer liest 16-Bit Daten vom I/O-Gerät
 		\end{tabular}
	\end{table}
\end{center}

Jede Interaktion benötigt dabei mehrere Schritte, die genaue Definition der Kommunikationsschritte wird dabei durch jede instruktion eigen festgelegt.
Ein allgemeiner standart Ablauf (wie z.B. der der später definierten IO-Instruktion "rmn") sieht wir folgt aus:

\begin{center}
	\begin{table}[h]
		\caption{\label{table:IO_Schem}}
		\begin{tabular}{l | l | l | l | l | l | l}
			 Bereich & Instr 1 & Instr 2 & ... & Instr n & Instr $n+1$ & ... \\
			\hline
			Iin & 1 & 0 &   & 0 & \\
			Din & 0 & 1 &   & 0 & \\
			Dout & 0 & 0 &   & 1 & \\
			Data$0-7$ & InstructionID & Variable &   & Rückgabewert & Rückgabewert \\
			Data$8-15$ & 8b Variable & Variable &   & Rückgabewert & Rückgabewert
 		\end{tabular}
	\end{table}
\end{center}

Die Pins Iin und Din werden dabei durch den Computer für einen Clock-Tick gesetzt, sobald die Daten/Instruktionsinformationen am Dateneingang an liegen; der Dout Pin wird durch das I/O-Gerät selbst gesetzt, sobald dieses seinerseits die Rückgabeinformation auf die Daten-pins anlegt.
Das setzen des Dout-pins wird vom Computer als Interupt( \autoref{section:interrupts}) bearbeitet.
Der fall, dass gleichzeitig der Computer und das I/O-Gerät die Datenpins versuchen zu beschreiben wird dadurch gelöst, dass meinstens die instruktionen definieren, wann das I/O-Gerät schreiben darf. Bei geräten, wie z.B. Peripherie-Geräten, die standartmäßig schreiben dürfen sollen ist von dem I/O-Gerät der Dout-pin schon eine Instruktion vor beginn des beschreibens des auf den Daten-pins zu setzen.

die Momentan bestehenden I/O-Instruktionen sind die folgenden, aber diese sind im Programm frei veränderlich, solange das externe Gerät die gleiche Interpretation der Anweisungen hat.

\begin{center}
	\begin{longtable}{p{0.045\textwidth} | p{0.1\textwidth} | p{0.1\textwidth} | p{0.40\textwidth} | p{0.22\textwidth}}[h]
	\kill
		\caption{\label{table:IOins}I/O-Instruktionen}
		\endhead
			ID & Gerätetyp & Name & Funktion & Verhalten \\
			\hline
			 $0\text{x}00$ & All & ls & gibt alle normalen Funktionen des Geräts zurück & Iin; n$*$Dout\\
			\hline
			 $0\text{x}01$ & All  & ll & gibt ALLE (auch die, die man nicht verwenden sollte) Funktionen zurück & Iin(Instruktion); n$*$Dout(Antworten)\\
			\hline
			 $0\text{x}02$ & Drive & rsn (read singel normal) & Lesen eines einzelnen 16-Bit werts von einer 24-Bit Addresse & Iin(Instruktion); Din(Addresse); 1$*$Dout(Antwort) \\
			\hline
			 $0\text{x}03$ & Drive & rmn (read multiple normal) & Lesen einer reihe an 16-Bit werten von 24-Bit Addressen aus & Iin(Instruktion); Din(startAddresse); Din(Länge); n$*$Dout(Antworten) \\
			\hline
			 $0\text{x}04$ & Drive & wsn (write singel normal) & Schreiben eines einzelnen 16-Bit werts von einer 24-Bit Addresse & Iin(Instruktion); Din(Addresse); Din(Daten); Dout(bestätigung) \\
			\hline
			 $0\text{x}05$ & Drive & wmn (write multiple normal) & Schreiben einer reihe an 16-Bit werten an 24-Bit Addressen & Iin(Instruktion); Din(startAddresse); n$*$Din(Daten); Dout(bestätigung) \\
			\hline
			 $0\text{x}06$ & Drive & rsb (singel read big) & Lesen eines einzelnen 16-Bit werts von einer 40-Bit Addresse & Iin(Instruktion); Din(Addresse); Din(Addresse); 1$*$Dout(Antwort) \\
			\hline
			 $0\text{x}07$ & Drive & rmb (multiple write big) & Lesen einer reihe an 16-Bit werten von 40-Bit Addressen aus & Iin(Instruktion); Din(startAddresse); Din(startAddresse2); Din(Länge); n$*$Dout(Antworten) \\
			\hline
			 $0\text{x}08$ & Drive & wmb (singel write big) & Schreiben eines einzelnen 16-Bit werts von einer 40-Bit Addresse & Iin(Instruktion); Din(Addresse); Din(Addresse);Din(Daten); 1$*$Dout(bestätigung) \\
			\hline
			 $0\text{x}09$ & Drive & wmb (write multiple big) & Schreiben einer reihe an 16-Bit werten an 40-Bit Addressen & Iin(Instruktion); Din(startAddresse); n$*$Din(Daten); Dout(bestätigung) \\
			\hline
			 $0\text{x}0a$ & Drive & rfn (read file normal) & Lesen einer gesamten Datei (24-bit Namen)  & Iin(Instruction); Din(Name); n$*$Dout(Antwort) \\
			\hline
			 $0\text{x}0b$ & Drive & wfn (write file normal) & Schreiben einer neuen Datei (24-bit Namen) & Iin(instruction); Din(Name); n$*$Din(daten); Dout(bestätigung) \\
			\hline
			 $0\text{x}0c$ & Drive & rfpb (read file-part big) & Lesen eines teils einer Datei (24-bit Namen) & Iin(instruction); Din(Name); 2$*$Din(läge); n$*$Dout(Daten) \\
			\hline
			 $0\text{x}0d$ & Drive & wfpb (write file-part big) & Anhängen von Daten an eine Datei(24-bit Namen) & Iin(instruction); Din(Name); Din(länge); n$*$Din(Daten); Dout(bestätigung) \\
			\hline
			 $0\text{x}0e$ &  & & & \\
			\hline
			 $0\text{x}0f$ &  & & &

	\end{longtable}
\end{center}


\subsubsection{\label{section:persmissionIO}Berechtigungsliste}

Berechtigungen: der Supervisor-mode hat die berechtigungen zu allen I/O-Interaktionen, für normale prozesse wird die Berechtigungsliste in einer reihe an RAM-chips gespeichert, deren Addressen sich mit dem wechseln zwischen den verschiedenen Banks ändern.
gesetzt werden können sie nur durch den Supervisor, wobei auch dieser die RAM-Addressen nicht manuel ändern kann (\autoref{section:insSet})




\subsection{\label{section:interrupts}Interrupts}

Interrupts sind Unterbrechungen im Programmablauf. Wenn ein Interrupt meldet wird. Wird dieser im nächsten Instruktions-Zyklus bearbeitet. Für diesen Zyklus, wird, je nach Interrupt-Quelle, nicht die Instruktion ander Stelle von IP sondern von IV (Interrupt Vektor) geladen.

Alle Interrupts werden blockiert wenn die OINT Flagge gesetzt ist. Blockiert heißt dabei das alle Interrupts nicht behandelt werden. Diese Flagge kann nur gesetzt werden wenn sicher der Computer im Supervisormode befindet. siehe \ref*{section:supervisor}

Wir unterscheiden dabei zwischen drei verschiedenen Interrupt-Quelle, wobei jede Quelle einen eigenen IV hat, wie in \autoref{table:iv}

\begin{center}	
	\begin{table}[h]
		\caption{\label{table:iv}}
		\begin{tabular}{l | l l}
			Interrupt-Quelle & IV Name & IV Standard Wert \\
			\hline
			IO-Interrupts & IV-IO & $0\texttt{x}0000$ \\
			INT-Instruktion & IV-INT & $0\texttt{x}0000$ \\
			Timed-Interrupts & IV-TI & $0\texttt{x}0000$ \\
		\end{tabular}
	\end{table}
\end{center}

\subsubsection{Timed-Interrupts}

Der Timed-Intrrupt funktioniert wie ein Wecker. Nachdem Ausführen der STI (Set Timed Interrupt) Instruktion, wird nach angebender Anzahl an ausgeführten Instruktion ein Intrrupt ausgelöst. So 
würde \texttt{STI 0x00ff} in 256 Instruktion einen Interrupt auslösen. Wenn ein Timed-Interrupt mit der Zeit \texttt{0x0000} gesetzt wird, so wird der Timed-Intrrupt deaktiviert.

\subsubsection{IO-Interrupts}

\subsection{\label{section:supervisor}Supervisor-/Usermode}

Der Computer hatte ein eingebautes Rechte-System. Er kann dabei in zwei Modi operieren: dem Supervisormode und Usermode. Im Supervisormode kann der Computer alle Funktion, ohne einschreckung, nutzen. Im Usermode hingegen ist der Computer in einigen Funktion eingeschrenckt. Folgendes kann der Computer im Usermode \emph{nicht} machen:

\begin{itemize}
	\item Setzen der SUP Flagge
	\item Änderung der OINT Flagge
	\item Lesen und/oder schreiben in den Bereichen von \texttt{0x0000} - \texttt{0x3fff} und \texttt{0xd000} - \texttt{0xffff}
	\item Änderung der Banken
	\item Die IO-Berechtigungsliste zu modifizieren
	\item Zugriff auf IO-Geräte, welche nicht in der Berechtigungsliste gespeichert sind (siehe \autoref{section:persmissionIO})
\end{itemize}

Der Modes des Computers (Supervisor or User) wird dabei in der SUP Flagge gespeichert. Eine gesetzte SUP Flagge entspricht dem Supervisormode und eine nicht gesetzte SUP dem Usermode Der Computer started dabei mit gestetzter SUP Flagge.

Zudem änderet sich je nach Modus des Computer die Start position des Stacks wie in \autoref{section:stack} erleutert.

Mehr zu der Motivation hinter diesem System in \autoref{com:sup}

\subsection{\label{section:insSet}Instruktions-Satz}

Alle zuverfügenung stehenden Instruktion sind in \autoref{table:instructions}. Die Ins-ID, steht für Instruktions-ID, welecher jeder Instruktion eine zugeordnet ist. op1, op2 und op3 sind dabei die möglich parameter der Instruktion. Sie können dabei Register (reg1, reg2 oder reg3) sein oder ein Konstante (c).

\begin{center}
	\begin{table*}
		\caption{\label{table:instructions}Instruktions-Satz}
		\begin{tabular}{l | l l l l | l}
			Ins-ID & Name & op1 & op2 & op3 & Beschreibung \\
			\hline
			\texttt{0x00} & NOP  &  &  &  & Kein Effekt  \\
			\hline
			\texttt{0x01} & MOV  & reg1 &  & reg3/c & reg1 $=$ reg3/c\\
			\texttt{0x02} & ADD  & reg1 & reg2 & reg3/c & reg1 $=$ reg2 $+$ reg3/c \\
			\texttt{0x03} & SUB  & reg1 & reg2 & reg3/c & reg1 $=$ reg2 $-$ reg3/c \\
			\texttt{0x04} & MUL? & reg1 & reg2 & reg3/c & reg1 $=$ reg2 $*$ reg3/c \\
			\texttt{0x05} & DIV? & reg1 & reg2 & reg3/c & reg1 $=$ reg2 $/$ reg3/c \\
			\texttt{0x06} & XOR  & reg1 & reg2 & reg3/c & reg1 $=$ reg2 $\oplus$ reg3/c \\
			\texttt{0x07} & AND  & reg1 & reg2 & reg3/c & reg1 $=$ reg2 $\land$ reg3/c \\
			\texttt{0x08} & OR   & reg1 & reg2 & reg3/c & reg1 $=$ reg2 $\lor$ reg3/c \\
			\texttt{0x09} & NOT  & reg1 &  & reg3/c & reg1 $=$ $\lnot$reg3/c \\
			\hline 
			\texttt{0x0a} & STR  & reg1 & reg2 & reg3/c & memory[reg2 + reg3/c] = reg1  \\
			\texttt{0x0b} & LD   & reg1 & reg2 & reg3/c & reg1 = memory[reg2 + reg3/c] \\
			\texttt{0x0c} & BNK1 &  &  & reg3/c & Setzt BID für Bank-Slot1 \\
			\texttt{0x0d} & BNK2 &  &  & reg3/c & Setzt BID für Bank-Slot2 \\
			\hline
			\texttt{0x0e} & PUSH &  &  & reg3/c & SP--; memory[SP] = reg1 \\
			\texttt{0x0f} & POP  &  &  & reg3 & reg3 = memory[SP]; SP++ \\
			\texttt{0x10} & CALL &  &  & reg3/c & \vtop{
				\hbox{\strut memory[SP] = IP; SP++;}
				\hbox{\strut IP = reg1/c}} \\
			\texttt{0x11} & RET  &  &  &  & IP = memory[SP]; SP++ \\
			\hline
			\texttt{0x12} & TEST & reg1 &  & reg3/c & Vergleicht reg1 und reg3/c \\
			\texttt{0x13} & ME   & reg1 &  & reg3/c & reg1 = reg3/c if E \\
			\texttt{0x14} & MOF  & reg1 &  & reg3/c & reg1 = reg3/c if O \\
			\texttt{0x15} & MG   & reg1 &  & reg3/c & reg1 = reg3/c if G \\
			\texttt{0x16} & ML   & reg1 &  & reg3/c & reg1 = reg3/c if L \\
			\texttt{0x17} & MS & reg1 &  & reg3/c & reg1 = reg3/c if SUP \\
			\texttt{0x18} & MI & reg1 &  & reg3/c & reg1 = reg3/c if OINT \\
			\hline
			\texttt{0x19} & IOUT & reg1 &  & reg3/c & IIO[reg1] = reg3/c \\
			\texttt{0x1a} & DOUT & reg1 &  & reg3/c & DIO[reg1] = reg3/c \\
			\texttt{0x1b} & DIN  & reg1 &  & reg3 & reg3 = DIO[reg1] \\
			\texttt{0x1c} & AIO  & reg1 &  &  & Aktiviert IO[reg1] \\
			\texttt{0x1d} & DIO  & reg1 &  &  & Deaktivieren IO[reg1] \\
			\hline
			\texttt{0x1e} & INT  & & & & Löst einen Interrupt aus \\
			\texttt{0x1f} & STI  & & & reg3/c & Setzt Timed Interrupt für reg1/c \\
			\hline
		\end{tabular}
	\end{table*}
\end{center}

\section{Kommentar zur Specification}

\subsection{\label{section:comment:datalength}16 bit Daten/Address Länge}

Die Address- und Datenlänge besagt viele Binäre Ziffern (bits) für eine Address und Daten verwendet werden. Je mehr Ziffern man verwendet desto größere Zahlen können in einer Operation verarbeitet werden wobei die maximal repräsentierbare Zahle $2^n - 1$ ist wenn $n$ die Anzahl der Binary Ziffern (= Bits) ist und wenn man mit $0$ anfängt zu zählen. Sie \autoref{table:max_zahlen}

Ein eine $n$ stellige Binär Zahl wobei $n$ teilbar durch $8$ ist, ist dabei relative angenehm, $8$ bit = $1$ byte. Das byte ist dabei die Basis Einheit für so gut wie alle informationstechnischen Standards. Daher ist es gute eine solches $n$ zu wählen.
Zudem kommen einige elementar ICs, z.B. Buffer oder Register, immer mit 8 bits.

Jedoch gilt je mehr Bits man verwendet, desto mehr Schaltung brauchen man, desto mehr Stromverbrauch. Da wir wie zwar nicht speziell auf Platz und Stromverbrauch optimieren, aber trozdem ein limitiertes Buget haben, können wir auch nicht eine belibig große Daten/Address Länge wählen.

Wir haben uns daher für $16$ bit entschieden, der Codea man laut \autoref{table:max_zahlen} Zahlen bis zwischen $0$ und $65535$ darstellen kann. Diese Menge ist gerade große genug, um für die meisten Programme große genüge Zahl abzubilden
\footnote{Für Programme die Zahlen welche $> 65535$ darstellen wohlen ist es ratsam immer zwei oder mehr Spreichereinheiten zunehmen oder bei Berechnungen, selbige auf zwei oder mehr Schritte auf zuteilen}.

Die Entscheidung zur größe der Daten/Address Länge ist eine sehr ausschlag gebende, daher haben wir diese zuerst festgelegt. Sie wird für viele weitere Entscheidung eine wichtige Rolle spielen. Wichtig ist nur das wir maximal $65536$ Zustände oder Zahlen von $0$ bis $65535$ darstellen können mit unseren $16$ bit

\begin{center}
	\begin{table}[h]
		\caption{\label{table:max_zahlen} Maximalerepersäntierbare Zahlen (startend mit 0)}
		\begin{tabular}{ l | l }
 		$n$ & $n^2 - 1$ \\
		\hline 
		2 & 3\\  
		4 & 15\\
		8 & 255\\
		16 & 65535\\
 		32 & 4294967295\\
 		64 & 18446744073709551615\\
		\end{tabular}
	\end{table}
\end{center}

\subsection{\label{section:comment:register_number}Register Anzahl}

Der Computer hat 8 Register. Wir haben uns für Acht ausfolgenden Gründen entschieden:
Zu erst die minimale Anzahl anregisteren die wirklich gebraucht würde, ist $5$! Man braucht mindestens zwei all Zweck Register um binäre Rechenoperation durch zu führen, einen Stackpointer, einen Instruktion Point und einen Ort wo man die Flaggen speichern kann
\footnote{Theorthisch ist es möglich das Flaggen Register wegzulassen, wir haben uns aber für eine solches Register entschieden siehe \autoref{com:conditionals}}.

Fünf lässt sich nicht mehr mit $2$ bits repräsentieren ($2^2 = 4$), daher muss man $3$ bit ($2^2 = 8$) nehmen. Der Grund warum wir nicht mehr genomen haben hat mit der Encodierung von Instruktionen zutun siehe \autoref{com:insEnc}. Somit haben sich $8$ Register als das Optimum ergeben

\subsection{\label{com:insEnc}Alternative Instruktion Encodierung}

\subsection{\label{com:sup}Gedanken Hinter dem Supervisormode}

\section{Quellenverzeichnis}

\printbibliography{}

\end{document}
