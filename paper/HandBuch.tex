\documentclass{scrartcl}

\usepackage{graphicx}
\usepackage[siunitx, RPvoltages, european]{circuitikz}

\usepackage[ngerman]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage[T1]{fontenc}
\usepackage{xcolor}
\usepackage{tikz}
\usepackage[breaklinks=true]{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[babel,german=quotes]{csquotes}
\usepackage[style=numeric, backend=biber]{biblatex}
\usepackage{listings}
\usepackage{bytefield}

\lstdefinestyle{asm}{
}

\addbibresource{ref.bib}

\graphicspath{ {../images} }

\KOMAoptions{parskip=full}

\begin{document}

\title{Platinencomputer - Handbuch}
\author{Alexander Wersching und Simon Walter}
\date{2021}
\maketitle
\newpage


\tableofcontents
\newpage

\section{Anforderungen und Methode}

\section{Spezifikation des Computers}
Eine Computer hat eine Reihe verschiedener high-level Aufgaben und Features, die es ihm erlauben seiner Tätigkeiten nach zu gehen! 
Diese Features können wie folgt auf gegliedert werden: Register, Memory, Banking, Input/Output, Flaggen, Hardware Stack, Interrupts, Supervisor-Mode und das Instructuion Set.

Aber um zuerst ein paar Standarts festzulegen: der Computer hat eine Daten/Adressen Länge von 16 bit, d.h. er kann maximal 16 bit auf einmal operieren bzw. können maximal 16 bit an Daten/Adressen im Computer auf einmal bewegt werden. Mehr dazu in \autoref{section:comment:datalength}



\subsection{Registers}
Register sind kleine sehr schnelle Speichereinheiten, die genutzt werden können um Zwischenergebnisse, lokal Variablen, Argumenten für Funktionen zu speichern oder um Daten im Computer zwischen den einzelnen Komponenten zu verschieben. Aus jedem Register kann \emph{gelesen} (\emph{Kopierten} des alten Wertes an eine anderen Ort) oder \emph{geschrieben} werden (den alten Wert mit einem neuen Wert \emph{überschreiben})

Der Computers besitzt bei uns $8$ verschiedene, jeweils $16$ bit lange Register. Jedes Register hat dabei eine eigene Registernumber (= RN). Machen Register erfüllen zudem noch spezielle Aufgaben und sollten auch nur so verwendet werden. Diese Funktionen sind in \autoref{table:register} zu sehen.

Mehr zur Registeranzahl in \autoref{section:comment:register_number}

\begin{center}
	\begin{table}[h]
		\caption{\label{table:register} Registeraufteilung}
		\begin{tabular}{l | l | l}
			RN & Name & Funktion\\
			\hline
			$0$ & ZERO & Konstante $0\text{x}0000$; Schreiben hat keinen Effekt\\
			$1$ & IP & Instruction Pointer, zeigt auf aktuell auszuführende Instruktion\\
			$2$ & SP & Stack Pointer, zeigt auf obersten Wert des Stacks, siehe \ref{section:stack} \\
			$3$ & A & Allzweck Register ohne besonderen Aufgaben \\
			$4$ & B & " \\
			$5$ & C & " \\
			$6$ & D & " \\
			$7$ & FLAG & Enthält alle wichtigen Flaggen, siehe \autoref{section:flags} \\
		\end{tabular}
	\end{table}
\end{center}

Die Register A-D sind dabei die Register, welche frei für jede Nutzung zur Verfügung stehen. Es ist \emph{stark zu empfehlen} die spezialregister (ZERO, IP, SP und FLAG) \emph{nicht} für die Speicherung von Daten zu verwenden, da dies evt. Programmabläufe stark stören könnte. Sie sind ausdrücklich nur für ihre zugewiesenen Aufgaben da.




\subsubsection{\label{section:flags}Flaggen}

Das Register FLAG enthält alle Statusflaggen. Eine Flagge kann entweder gesetzt oder nicht gesetzt sein, daher kann jede Flagge als ein Bit repräsentiert werden. Jedes Bit in FLAG stellt daher eine Flagge da. Flaggen werden bei unterschiedlichen Ereignissen geschaltet. Dies und welche Flaggen es gibt ist in \autoref{table:flag} zusehen

\begin{center}
	\begin{table}[h]
		\caption{\label{table:flag}Flaggenaufteilung in FLAG}
		\begin{tabular}{l | l | l | l}
			Bit & Name & Funktion & Schaltung \\
			\hline
			 0 & OF  & Intager Overflow einer Rechenoperation & Bei jeder ALU Operation\\
			 1 & E   & Gleichheit zweier Werte & TEST arg[0] = arg[1]\\
			 2 & G   & Ungleicheit ($>$) zweier Werte & TEST arg[0] > arg[1]\\
			 3 & L   & Ungleicheit ($<$) zweier Werte & TEST arg[0] < arg[0]\\
			 4 &  &  &  \\
			 5 &  &  &  \\
			 6 &  &  &  \\
			 7 &  &  &  \\
			 8 &  &  &  \\
			 9 &  &  &  \\
			10 &  &  &  \\
			11 &  &  &  \\
			12 &  &  &  \\
			13 &  &  &  \\
			14 &  &  &  \\
			15 & SUP & Supervisor-/Usermode & siehe \autoref{section:interrupts} 
		\end{tabular}
	\end{table}
\end{center}

Alle Flaggen, die mit TEST als Schaltung gekennzeichnet werden, werden bei der Ausführung der TEST Operation geschaltet.

Das FLAG Register verhält sich ebenfalls wie ein Register, daher können Flagge auch per Hand gesetzt oder nicht gesetzt werden. Eine Ausnahme macht SUP die nur manuel geschaltet werden kann wenn SUP gesetzt ist, siehe \autoref{section:supervisor}




\subsection{\label{section:memory}Memory}

Während die Register für lokale Variablen und Zwischenergebnisse gedacht sind, ist Memory (Arbeitsspeicher) für die Speicherung von größeren Datenmengen gedacht.

Es ist in 65536 einzelne und unabhängige Speicherzellen (Jede 16 bit große) aufgeteilt. Jeder Zelle ist einer Addresse, welche von 0 bis 65535 reicht, zugeordnet. Der Computer kann damit auf $65536 \text{words}$ oder $131072 \text{bytes}$ ($\approx 131.0 \text{kb}$) gleichzeitig zugreifen.
\footnote{Die Größe messen wir in words (w) oder in kilowords (kw), wobei $1 \text{word} = 2 \text{bytes} = 16 \text{bit}$.}. Wichtig ist das die Gesamt Größe theoretisch weitaus größer sein kann, dank Banking siehe \autoref{section:banking}.

Memory wird dabei über LD- und STR-Instruktionen gesteuert. Die LD-Instruktion kopiert einen Wert aus Memory und schreibt ihn in ein Register, während STR an der angebenen Addresse den Wert mit dem eines Register überschreibt.

Dabei ist die Memory Karte in \autoref{fig:memoryMap} zu stehen. Die zwei Hardware Stacks sind dort gekenzeichnet mit $\uparrow$, mehr dazu in \autoref{section:stack}

Die mit Supervisor gekennzeichneten Bereich können nur dann gelesen oder geschrieben werden, wenn die SUP Flagge gesetzt ist. Der Bereich, der mit ROM versehen wurde, ist dabei nicht beschreibbar, sondern kann nur gelesen werden. Eine STR Instruktion hat keine Wirkung.

\begin{figure}[h]
	\centering
	\caption{Memory Karte}
	\label{fig:memoryMap}
	\begin{bytefield}[leftcurly=., rightcurly=., leftcurlyspace=0pt, rightcurlyspace=0pt]{16}
		
		\begin{leftwordgroup}{\small \texttt{0x0000}}
			\bitbox[lrt]{16}{}
		\end{leftwordgroup}\\
		\wordbox[lr]{2}{ROM Supervisor\\$16384 \text{w} \approx 16.3 \text{kw}$} \\
		\begin{leftwordgroup}{\small \texttt{0x3fff}}
			\bitbox[lr]{16}{}
		\end{leftwordgroup}\\

		\begin{leftwordgroup}{\small \texttt{0x4000}}
			\bitbox[lrt]{16}{}
		\end{leftwordgroup}\\
		\begin{rightwordgroup}{\large $\uparrow$ User Stack}
			\wordbox[lr]{3}{RAM (Bank Slot 1)\\$18431 \text{w} \approx 18.4 \text{kw}$} \\
		\end{rightwordgroup}
		\begin{leftwordgroup}{\small \texttt{0x57ff}}
			\bitbox[lr]{16}{}
		\end{leftwordgroup}\\

		\begin{leftwordgroup}{\small \texttt{0x5800}}
			\bitbox[lrt]{16}{}
		\end{leftwordgroup}\\
		\wordbox[lr]{3}{RAM (Bank Slot 2)\\$18431 \text{w} \approx 18.4 \text{kw}$} \\
		\begin{leftwordgroup}{\small \texttt{0xcfff}}
			\bitbox[lr]{16}{}
		\end{leftwordgroup}\\

		\begin{leftwordgroup}{\small \texttt{0xd000}}
			\bitbox[lrt]{16}{}
		\end{leftwordgroup}\\
		\begin{rightwordgroup}{\large $\uparrow$ Supervisor Stack}
			\wordbox[lr]{2}{RAM Supervisor\\$12287 \text{w} \approx 12.3 \text{kw}$} \\
		\end{rightwordgroup}
		\begin{leftwordgroup}{\small \texttt{0xffff}}
			\bitbox[lrb]{16}{}
		\end{leftwordgroup}

	\end{bytefield}
	
\end{figure}

\subsubsection{\label{section:banking}Banking}

Banken sind externe Memory Module, die eingesteckt werden können. Alle Banken sind gleich groß ($~18.4\text{kw} = 36.8\text{kb}$) und der Computer unterstützt maximal $65536$ unterschiedliche Banken. Jede Bank hat dabei eine ID (BID), die von $0$ bis $65535$ reicht.

Der Computer hat zwei Bank-Slots (Slot 1 \texttt{0x4000 - 0x3fff} und Slot 2 \texttt{0x4000 - 0x57ff}). Er kann nun auf jenden dieser Slots eine der theoretisch $65536$ Bank legen
\footnote{Es ist dabei möglich die gleiche Bank auf beide Slots zu legen, auch wenn das nur bedingt nützlich ist.}. Das Banken legen lässt sich über die SBK1- (Select Bank 1) und SBK2- (Select Bank 2) Instruktion erreichen.
Wenn man somit an diese entsprechende Memory Addressen schreibt, schreibt man in die Bank hinein.

Durch dieses System lassen sich $65536 * ~18.4\text{kw} = 1.2\text{Gw} = 2.4\text{GB}$ ansprechen.

Das Bankensystem dient zudem dazu Prozesse von einander zu isolieren, da bei nicht gesetzter SUP-Flagge Computer die Bank nicht änderen kann, siehe \autoref{section:supervisor}.

\subsubsection{\label{section:stack}Hardware Stack}

Der Stack (oder auch Stapelspeicher) ist eine LIFO (Last In First Out) Datenstruktur. Sie dient hauptsächlich dazu Subroutinen zu verwalten. 

Er funktioniert dabei wie ein Münztappel. Es kann ein Wert auf den Stack gelegt werden (PUSH-Instruktion) oder ein Wert von oben abgehoben werden (POP-Instruktion).

Der Stack liegt dabei physisch in Memory vor. Jedes Element des Stacks okkupiert dabei eine Memoryzelle. Das Stack-Point Register-(SP) hält die Addresse, welche auf den oberste Wert des Stacks zeigt. Der Stack wächst dabei von hohen Addressen zu niedrigen Addressen. PUSH entspricht dabei der Dekrementierung des Stack Pointers um $1$ und POP der Inkrementierung um $1$.

Fundamental hat der Computer zwei Stacks. Der Supervisor-Stack beginnt bei \texttt{0xffff} und wird genutzt wenn die SUP Flagge gesetzt ist. Der User-Stack beginnt bei \texttt{0x57ff}, also am Ende des Bank-Slots 1 und wird genutzt, wenn die SUP Flagge nicht gesetzt ist.

POP und PUSH schalten automatisch zwischen Supervisor-Stack und User-Stack bei Änderung der SUP-Flagge.




\subsection{\label{section:io}Input/Output}

Der Computer hat zudem die Möglichkeit mit verschieden IO-Geräte zu interagieren. Jedes IO-Geräte hat eine ID (IO-ID). Diese reicht von $0$ bis $65535$. Die Kommunikation zwischen Computer und IO-Geräte funktioniert über IN bzw OUT Instruktion. IN Ließt einen Wert vom IO-Geräte. Und OUT schreibt eine Wert zum IO-Gerät. 

Im Supervisormode kann jedes IO-Geräte uneingeschränkt verwendet werden. Im Usermode hingegen sind standartmässig alle IO-Geräte gesperrt. Der Supervisor kann sie dauerhaft freigeben oder sie wieder sperren, mit AIO (Allow Input/Output), für das Aktivieren und DIO (Disallow Input/Output) für das Deaktivieren. Diese Information wird in einem Seperatem Speichermodule gesichert, wobei die Speicheraddresse von der BID (Bank ID) abhängt.

Jedes IO-Geräte hat eine feste unveränderliche Typennummer. Diese lassen sich über die TYPE Instruktion erfahren. Die Typennummer $0\texttt{x}0000$ markiert dabei ein nicht eingestecktes Geräte. Mehr zu IO-Geräte in \autoref{section:devices}

\subsection{\label{section:interrupts}Interrupts}

REWORK!




\subsection{\label{section:supervisor}Supervisor-/Usermode}

REWORK

\subsection{\label{section:insSet}Instruktions-Satz}

Alle zuverfügenung stehenden Instruktion sind in \autoref{table:instructions}. Die Ins-ID, steht für Instruktions-ID, welecher jeder Instruktion eine zugeordnet ist. op1, op2 und op3 sind dabei die möglich parameter der Instruktion. Sie können dabei Register (reg1, reg2 oder reg3) sein oder ein Konstante (c).

\begin{center}
	\begin{table*}
		\caption{\label{table:instructions}Instruktions-Satz}
		\begin{tabular}{l | l l l l | l}
			Ins-ID & Name & op1 & op2 & op3 & Beschreibung \\
			\hline
			$0\texttt{x}00$ & NOP  &  &  &  & Kein Effekt  \\
			\hline
			$0\texttt{x}01$ & MOV  & reg1 & reg2/c &  & reg1 $=$ reg2/c\\
			$0\texttt{x}02$ & ADD  & reg1 & reg2 & reg3/c & reg1 $=$ reg2 $+$ reg3/c \\
			$0\texttt{x}03$ & SUB  & reg1 & reg2 & reg3/c & reg1 $=$ reg2 $-$ reg3/c \\
			$0\texttt{x}03$ & MUL? & reg1 & reg2 & reg3/c & reg1 $=$ reg2 $*$ reg3/c \\
			$0\texttt{x}05$ & DIV? & reg1 & reg2 & reg3/c & reg1 $=$ reg2 $/$ reg3/c \\
			$0\texttt{x}06$ & XOR  & reg1 & reg2 & reg3/c & reg1 $=$ reg2 $\oplus$ reg3/c \\
			$0\texttt{x}07$ & AND  & reg1 & reg2 & reg3/c & reg1 $=$ reg2 $\land$ reg3/c \\
			$0\texttt{x}08$ & OR   & reg1 & reg2 & reg3/c & reg1 $=$ reg2 $\lor$ reg3/c \\
			$0\texttt{x}09$ & NOT  & reg1 & reg2/c &      & reg1 $=$ $\lnot$reg2/c \\
			\hline 
			$0\texttt{x}0\texttt{a}$ & STR  & reg1 & reg2 & reg3/c & memory[reg2 + reg3/c] = reg1  \\
			$0\texttt{x}0\texttt{b}$ & LD   & reg1 & reg2 & reg3/c & reg1 = memory[reg2 + reg3/c] \\
			$0\texttt{x}0\texttt{c}$ & BNK1 & reg1/c &  &  & Setzt BID für Bank-Slot1 \\
			$0\texttt{x}0\texttt{d}$ & BNK2 & reg1/c &  &  & Setzt BID für Bank-Slot2 \\
			\hline
			$0\texttt{x}0\texttt{e}$ & PUSH & reg1/c &  &  & SP--; memory[SP] = reg1 \\
			$0\texttt{x}0\texttt{f}$ & POP  & reg1 &  &  & reg1 = memory[SP]; SP++ \\
			$0\texttt{x}10$ & PEEK & reg1 &  &  & reg1 = memory[SP] \\
			$0\texttt{x}11$ & CALL & reg1/c &  &  & \vtop{
				\hbox{\strut memory[SP] = IP; SP++;}
				\hbox{\strut IP = reg1/c}} \\
			$0\texttt{x}12$ & RET  &  &  &  & IP = memory[SP]; SP++ \\
			\hline
			$0\texttt{x}12$ & TEST & reg1 & reg2/c &  & Vergleicht reg1 und reg2/c \\
			$0\texttt{x}13$ & JE   & reg1/c &  &  & IP = reg1/c if E \\
			$0\texttt{x}14$ & JO   & reg1/c &  &  & IP = reg1/c if O \\
			$0\texttt{x}15$ & JG   & reg1/c &  &  & IP = reg1/c if G \\
			$0\texttt{x}16$ & JL   & reg1/c &  &  & IP = reg1/c if L \\
			\hline
			$0\texttt{x}16$ & IN   & reg1 & reg2 &  & reg1 = IO[reg2] \\
			$0\texttt{x}17$ & OUT  & reg1/c & reg2 &  & IO[reg2] = reg1/c \\
			$0\texttt{x}18$ & AIO  & reg1 &  &  & Aktiviert IO[reg1] \\
			$0\texttt{x}19$ & DIO  & reg1 &  &  & Deaktivieren IO[reg1] \\
			$0\texttt{x}1\texttt{a}$ & TYPE & reg1 & reg2 &  & reg1 = Type von IO[reg2] \\
			\hline
		\end{tabular}
	\end{table*}
\end{center}

\section{Kommentar zur Specification}

\subsection{\label{section:comment:datalength}16 bit Daten/Address Länge}
Die Address- und Datenlänge besagt viele Binäre Ziffern (bits) für eine Address und Daten verwendet werden. Je mehr Ziffern man verwendet desto größere Zahlen können in einer Operation verarbeitet werden wobei die maximal repräsentierbare Zahle $2^n - 1$ ist wenn $n$ die Anzahl der Binary Ziffern (= Bits) ist und wenn man mit $0$ anfängt zu zählen. Sie \autoref{table:max_zahlen}

Ein eine $n$ stellige Binär Zahl wobei $n$ teilbar durch $8$ ist, ist dabei relative angenehm, $8$ bit = $1$ byte. Das byte ist dabei die Basis Einheit für so gut wie alle informationstechnischen Standards. Daher ist es gute eine solches $n$ zu wählen.
Zudem kommen einige elementar ICs, z.B. Buffer oder Register, immer mit 8 bits.

Jedoch gilt je mehr Bits man verwendet, desto mehr Schaltung brauchen man, desto mehr Stromverbrauch. Da wir wie zwar nicht speziell auf Platz und Stromverbrauch optimieren, aber trozdem ein limitiertes Buget haben, können wir auch nicht eine belibig große Daten/Address Länge wählen.

Wir haben uns daher für $16$ bit entschieden, der Codea man laut \autoref{table:max_zahlen} Zahlen bis zwischen $0$ und $65535$ darstellen kann. Diese Menge ist gerade große genug, um für die meisten Programme große genüge Zahl abzubilden
\footnote{Für Programme die Zahlen welche $> 65535$ darstellen wohlen ist es ratsam immer zwei oder mehr Spreichereinheiten zunehmen oder bei Berechnungen, selbige auf zwei oder mehr Schritte auf zuteilen}.

Die Entscheidung zur größe der Daten/Address Länge ist eine sehr ausschlag gebende, daher haben wir diese zuerst festgelegt. Sie wird für viele weitere Entscheidung eine wichtige Rolle spielen. Wichtig ist nur das wir maximal $65536$ Zustände oder Zahlen von $0$ bis $65535$ darstellen können mit unseren $16$ bit

\begin{center}
	\begin{table}[h]
		\caption{\label{table:max_zahlen} Maximalerepersäntierbare Zahlen (startend mit 0)}
		\begin{tabular}{ l | l }
 		$n$ & $n^2 - 1$ \\
		\hline 
		2 & 3\\  
		4 & 15\\
		8 & 255\\
		16 & 65535\\
 		32 & 4294967295\\
 		64 & 18446744073709551615\\
		\end{tabular}
	\end{table}
\end{center}

\subsection{\label{section:comment:register_number}Register Anzahl}

Der Computer hat 8 Register. Wir haben uns für Acht ausfolgenden Gründen entschieden:
Zu erst die minimale Anzahl anregisteren die wirklich gebraucht würde, ist $5$! Man braucht mindestens zwei all Zweck Register um binäre Rechenoperation durch zu führen, einen Stackpointer, einen Instruktion Point und einen Ort wo man die Flaggen speichern kann
\footnote{Theorthisch ist es möglich das Flaggen Register wegzulassen, wir haben uns aber für eine solches Register entschieden siehe \autoref{com:conditionals}}.

Fünf lässt sich nicht mehr mit $2$ bits repräsentieren ($2^2 = 4$), daher muss man $3$ bit ($2^2 = 8$) nehmen. Der Grund warum wir nicht mehr genomen haben hat mit der Encodierung von Instruktionen zutun siehe \autoref{com:insEnc}. Somit haben sich $8$ Register als das Optimum ergeben

\subsection{\label{com:insEnc}Alternative Instruktion Encodierung}

\section{Grundlegen Tests der Einzelnen Komponenten}

\section{\label{section:security}Security}

\section{\label{section:devices}Perepheriegeräte}

\begin{center}
	\begin{table}
		\caption{\label{table:device_types}Typennummern}
		\begin{tabular}{ l | l | l}
			Typennummer & Typename & Hinweis \\
			\hline
			$0\texttt{x}0000$ & NC & Keine Verbindung \\
			$0\texttt{x}0001$ & & \\
			... & & Nicht Besetzt \\
			$0\texttt{xffff}$ & & \\
		\end{tabular}
	\end{table}
\end{center}

\section{Quellenverzeichnis}

\printbibliography{}

\end{document}
